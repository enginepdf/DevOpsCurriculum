# Quest 16. 배포 파이프라인

## Introduction
* 이번 퀘스트에서는 CI/CD 파이프라인이 왜 필요한지, 어떻게 구축할 수 있는지 등에 대해 다룹니다.

## Topics
* Continuous Integration
* Continuous Delivery
* AWS Codebuild

## Resources
* https://aws.amazon.com/ko/devops/continuous-integration/
* https://aws.amazon.com/ko/devops/continuous-delivery/
* https://aws.amazon.com/ko/codebuild/getting-started/

## Checklist
* CI/CD는 무엇일까요? CI/CD 시스템을 구축하면 어떤 장점이 있을까요?

        Source Control(commit changes) -> Build(run build and unit tests) -> Staging(deploy to test environment, run integration tests, load tests, and other test) -> Production(deploy to production environment)

        Continuous Integration(지속적 통합)

            자동화된 빌드 및 테스트가 수행된 후, 개발자가 코드 변경 사항을 중앙 리포지토리에 정기적으로 병합하는 DevOps 소프트웨어 개발 방식
            자동화 구성 요소(CI 또는 빌드 서비스)와 문화적 구성 요소(빈번하게 통합하도록 학습) 모두 포함
            핵심 목표는 버그를 신속하게 찾아 해결, 소프트웨어 품질 개선, 새로운 소프트웨어 업데이트 검증 및 릴리스하는 데 걸리는 시간 단축

            --> 이전에는 팀의 개발자가 장기간 격리된 상태로 작업 완료 후에 변경 사항을 마스터 브랜치에 병합
                병합 코드가 어렵고 시간 소모적으로 변하게 되었고 수정 없이 오랫동안 버그가 축적되는 결과 나타남
                이러한 요소로 고객에게 업데이트를 신속하게 제공하기 더 어려워짐

                개발자 생산성 향상

                    개발자가 수동 작업에 대한 부담을 덜고 고객에게 제공되는 오류 및 버그 수를 줄이는 데에 도움이 되는 기능을 활용하여 팀의 생산성을 높일 수 있음

                버그를 더 빠르게 발견 및 해결

                    테스트를 좀 더 빈번하게 수행하여 팀에서는 이후에 더 큰 문제로 발전하기 전에 버그를 조기에 발견하고 해결 가능

                업데이트를 더 빠르게 제공

                    지속적 통합을 사용하면 팀이 좀 더 빠르고 좀 더 빈번하게 고객에게 업데이트를 제공 가능

        Continuous Delivery(지속적 전달)

            프로덕션으로 릴리스하기 위한 코드 변경이 자동으로 준비되는 소프트웨어 개발 방식
            빌드 단계 이후의 모든 코드 변경을 테스트 환경 및/또는 프로덕션 환경에 배포하여 지속적 통합을 확장
            개발자는 언제나 즉시 배포할 수 있고 표준화된 테스트 프로세스(UI, 로드, 통합 API 안정성 테스트)를 통과한 빌드 아티팩트 보유 가능
            개발자는 업데이트를 좀 더 철저히 검증하고 문제를 사전에 발견 가능
                온프레미스에서는 힘들었지만, 클라우드에서는 테스트용으로 여러 개의 환경을 생성하고 복제하는 작업을 비용 효율적으로 자동화 가능
            모든 코드 변경이(수정 버전이 커밋될 때마다) 업데이트를 빌드 및 테스트된 후, 비프로더션 테스트 또는 스테이징 환경으로 푸시(자동화된 흐름이 트리거 됨)
                전체 소프트웨어 릴리스 프로세스 자동화
            프로덕션 배포 전에 여러 개의 병렬 테스트 단계가 있을 수 있음
            프로덕션에 업데이트에 대한 수동 승인 절차가 존재. 라이브 프로덕션 환경에 배포하는 최종 결정은 개발자가 트리거(지속적 배포의 경우 프로덕션에 업데이트에 대한 명시적 승인 없이 자동으로 프로덕션이 일어남)

                소프트웨어 릴리스 프로세스 자동화

                    팀에서 프로덕션에 릴리스하기 위한 코드 변경을 자동으로 빌드, 테스트 및 준비하여, 좀 더 빠르고 효율적으로 소프트웨어 전달 가능

                개발자 생산성 향상

                    개발자가 수동 작업에 대한 부담을 덜고 고객에게 배포되는 오류 및 버그 수를 줄이는 데에 도움이 되는 기능을 활용하여 팀의 생산성을 높일 수 있음

                버그를 더 빠르게 발견 및 해결

                    좀 더 자주 포괄적으로 테스트를 수행하여 더 큰 문제로 발전하기 전에 버그를 발견하고 해결 가능
                    지속적 전달의 경우 전체 프로세스가 자동화되어 있어 다른 유형의 테스트를 손쉽게 추가하여 수행 가능

                업데이트를 더 빠르게 제공

                    팀이 좀 더 빠르고, 빈번하게 고객에게 업데이트를 제공 가능
                    지속적 전달이 적절하게 구현되면, 언제나 즉시 배포할 수 있고 표준화된 테스트 프로세스를 통과한 빌드 아티팩트 보유하게 됨

* CI 시스템인 Travis CI, Jenkins, Circle CI, Github Actions, AWS Codebuild 의 차이점과 장단점은 무엇일까요?

## Quest
* AWS Codebuild를 이용하여, 특정 브랜치에 푸시를 하면 테스트를 한 뒤 모노리포에 있는 모든 패키지가 한 번에 배포되는 시스템을 만들어 보세요.

        ```buildspec.yml on root for CodeBuild(수정 필요함)

            version: 0.2

            phases: 
                install:
                    runtime-versions:
                        nodejs: 
                    commands:
                        - echo Entering install phase...
                pre_build:
                    commands: 
                        - echo Entering pre_build phase... 
                        - npx lerna run test   
                build: 
                    commands:
                        - echo Entering build phase...
                        - ./build.sh
                        - ./deploy.sh

        ```

        ```deploy.sh

            #!/bin/bash
        
        ```

* 이 시스템의 CI/CD를 더 효율적으로 할 수 있는 아이디어에는 어떤 것들이 있을까요? 다섯 가지 이상의 아이디어를 제시해 보세요.(https://www.jetbrains.com/ko-kr/teamcity/ci-cd-guide/ci-cd-best-practices/)

        조기에 자주 커밋

            지속적 통합은 작은 업데이트를 더 자주 공유하여 여러 기여자의 변경 사항을 통합하는 프로세스를 보다 간편하게 하는 것
            각각의 커밋은 일련의 자동화된 테스트를 트리거하여 변경 사항에 대한 즉각적 피드백 제공
            주기적 커밋을 통해 팀원들이 동일 기반에서 작업할 수 있어 협업 촉진되고 복잡한 대규모 변경 사항을 통합할 때 병합 충돌의 가능성 감소
            지속적 통합의 이점을 활용하려면 모두가 메인(마스터) 브랜치로 푸시하여 다른 팀원들에게 변경 사용 공유하고 작업 사본을 업데이트하여 다른 모든 사람의 변경 사항 수신(일반적으로 하루에 한 번 이상 메인(마스터) 브랜치 커밋을 목표로 하는 것이 좋음)
                작업을 더 작은 별개의 부분으로 쪼개어 팀으로 일하면 개별 팀원이 이러한 작업 채택에 도움이 될 수 있음
            

        빌드를 그린으로 유지

            문제 발생 즉시 해결하면 훨씬 더 효율적이고 프로덕션에서 문제 발생 시에 수정 사항 신속 적용 가능
            빌드 실패 시 다시 작동하게 수정하는 것이 팀의 우선순위여야 함
            팀원들이 변경 사항을 공유하기 앞서 먼저 빌드를 수행하고 로컬로 초기 테스트 세트를 실행하는 것이 좋음(모두가 CI/CD 시스템과 동일한 스크립트 사용하여 중복 작업 방지)

        단 한 번만 빌드

        테스트 간소화

            CI/CD의 목표는 신속한 피드백을 제공하여 사용자에게 가치 있는 소프트웨어를 기존 방식보다 더욱 빠르게 전달하는 것이므로 테스트 커버리지와 성능 간의 균형 필요
            최대한 빠른 피드백을 위해 가장 신속히 완료되는 테스트 실행하고 빌드에 대해 어느 정도 확신이 가는 경우에만 더 오랜 시간이 소요되는 테스트(GUI 테스트, 성능/부하 테스트, 보안 테스트, 수동 탐색, 수용 테스트)에 투자

        환경 정리

            테스트 프로세스의 적절한 활용을 위해 각 배포 사이의 사전 프로덕션 환경 환경을 정리하는 것이 좋음
            환경이 장기간 실행 중이면, 각 환경에 적용된 모든 구성 변경 사항과 업데이트를 추적하기가 점차 어려워짐
            시간이 흐르며 초기 설정 및 다른 환경과의 차이 발생하기 마련이므로, 특정 환경에서 통과하거나 실패한 테스트가 다른 환경에서 동일 결과 반환하지 않을 수 있음
            정적 환경 유지하는 데 관리 비용이 수반되어 테스트 속도 저해 및 릴리스 프로세스 지연 문제 발생 가능
            컨테이너를 사용하여 환경 호스팅하고 테스트 실행할 경우, 해당 단계를 스크립트로 작성하는 코드로서 인프라 접근 방식을 통해 각각의 새로운 배포를 위한 환경을 간편하게 생성하고 해체 가능
                매번 새로운 컨테이너 인스턴스화 하면 일관성 보장되고 환경을 보다 쉽게 확장할 수 있어 필요한 경우 여러 빌드의 동시 테스트 실행 가능

        신뢰할 수 있는 프로덕션 배포 방식

            안정성, 속도, 보안을 모두 갖춘 CI/CD 파이프라인을 구축하는 데 투자했다면 이는 빌드의 품질에 대한 확신 제공
            자동화된 테스트 단계를 생략하는 경우 방지할 수 있는 이슈를 초래할 위험이 있고 테스트 환경에 배포할 빌드를 쉽게 이용할 수 없어 이슈의 재현 및 디버깅이 훨씬 어려움

        파이프라인 모니터링 및 평가

            CI/CD 도구를 통해 수집한 측정 기준을 분석하여 잠재적 문제와 개선 영역 파악 가능
            주, 일 또는 시간 단위로 트리거 되는 빌드 수를 비교하여 파이프라인 인프라가 사용되는 방식, 확장 또는 축소 필요성, 최대 부하 발생 가능성이 높은 시점 등에 대한 유용한 인사이트 도출 가능
            시간 경과에 따른 배포 속도를 추적하고 더 오랜 시간이 소요되는 경향을 모니터링하면 성능 최적화에 투자할 시점 알 수 있음
            자동화된 테스트로 얻은 통계 자료는 병렬화를 활용하면 좋은 영역을 결정하는 데 도움이 됨
            테스트 결과 검토를 통해 자주 간과하는 부분을 발견하여 테스트 커버리지를 간소화 할 수 있는 영역 파악 가능

        팀으로 협업

            개발자, 테스터 및 운영 팀 간의 통상적 사일로를 제거하고 여러 분야의 협업을 촉진
            소프트웨어 제공과 관련한 공동의 책임감을 조성하여 모든 팀원이 빌드 수정에 참여하거나, 환경 컨테이너화에 시간을 할애하거나 예상만큼 자주 수행되지 않는 수동 작업을 자동화하는 등 팀에 기여하도록 장려 가능
