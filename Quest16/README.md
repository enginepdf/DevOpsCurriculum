# Quest 16. 배포 파이프라인

## Introduction
* 이번 퀘스트에서는 CI/CD 파이프라인이 왜 필요한지, 어떻게 구축할 수 있는지 등에 대해 다룹니다.

## Topics
* Continuous Integration
* Continuous Delivery
* AWS Codebuild

## Resources
* https://aws.amazon.com/ko/devops/continuous-integration/
* https://aws.amazon.com/ko/devops/continuous-delivery/
* https://aws.amazon.com/ko/codebuild/getting-started/

## Checklist
* CI/CD는 무엇일까요? CI/CD 시스템을 구축하면 어떤 장점이 있을까요?

        Source Control(commit changes) -> Build(run build and unit tests) -> Staging(deploy to test environment, run integration tests, load tests, and other test) -> Production(deploy to production environment)

        Continuous Integration(지속적 통합)

            자동화된 빌드 및 테스트가 수행된 후, 개발자가 코드 변경 사항을 중앙 리포지토리에 정기적으로 병합하는 DevOps 소프트웨어 개발 방식
            자동화 구성 요소(CI 또는 빌드 서비스)와 문화적 구성 요소(빈번하게 통합하도록 학습) 모두 포함
            핵심 목표는 버그를 신속하게 찾아 해결, 소프트웨어 품질 개선, 새로운 소프트웨어 업데이트 검증 및 릴리스하는 데 걸리는 시간 단축

            --> 이전에는 팀의 개발자가 장기간 격리된 상태로 작업 완료 후에 변경 사항을 마스터 브랜치에 병합
                병합 코드가 어렵고 시간 소모적으로 변하게 되었고 수정 없이 오랫동안 버그가 축적되는 결과 나타남
                이러한 요소로 고객에게 업데이트를 신속하게 제공하기 더 어려워짐

                개발자 생산성 향상

                    개발자가 수동 작업에 대한 부담을 덜고 고객에게 제공되는 오류 및 버그 수를 줄이는 데에 도움이 되는 기능을 활용하여 팀의 생산성을 높일 수 있음

                버그를 더 빠르게 발견 및 해결

                    테스트를 좀 더 빈번하게 수행하여 팀에서는 이후에 더 큰 문제로 발전하기 전에 버그를 조기에 발견하고 해결 가능

                업데이트를 더 빠르게 제공

                    지속적 통합을 사용하면 팀이 좀 더 빠르고 좀 더 빈번하게 고객에게 업데이트를 제공 가능

        Continuous Delivery(지속적 전달)

            프로덕션으로 릴리스하기 위한 코드 변경이 자동으로 준비되는 소프트웨어 개발 방식
            빌드 단계 이후의 모든 코드 변경을 테스트 환경 및/또는 프로덕션 환경에 배포하여 지속적 통합을 확장
            개발자는 언제나 즉시 배포할 수 있고 표준화된 테스트 프로세스(UI, 로드, 통합 API 안정성 테스트)를 통과한 빌드 아티팩트 보유 가능
            개발자는 업데이트를 좀 더 철저히 검증하고 문제를 사전에 발견 가능
                온프레미스에서는 힘들었지만, 클라우드에서는 테스트용으로 여러 개의 환경을 생성하고 복제하는 작업을 비용 효율적으로 자동화 가능
            모든 코드 변경이(수정 버전이 커밋될 때마다) 업데이트를 빌드 및 테스트된 후, 비프로더션 테스트 또는 스테이징 환경으로 푸시(자동화된 흐름이 트리거 됨)
                전체 소프트웨어 릴리스 프로세스 자동화
            프로덕션 배포 전에 여러 개의 병렬 테스트 단계가 있을 수 있음
            프로덕션에 업데이트에 대한 수동 승인 절차가 존재. 라이브 프로덕션 환경에 배포하는 최종 결정은 개발자가 트리거(지속적 배포의 경우 프로덕션에 업데이트에 대한 명시적 승인 없이 자동으로 프로덕션이 일어남)

                소프트웨어 릴리스 프로세스 자동화

                    팀에서 프로덕션에 릴리스하기 위한 코드 변경을 자동으로 빌드, 테스트 및 준비하여, 좀 더 빠르고 효율적으로 소프트웨어 전달 가능

                개발자 생산성 향상

                    개발자가 수동 작업에 대한 부담을 덜고 고객에게 배포되는 오류 및 버그 수를 줄이는 데에 도움이 되는 기능을 활용하여 팀의 생산성을 높일 수 있음

                버그를 더 빠르게 발견 및 해결

                    좀 더 자주 포괄적으로 테스트를 수행하여 더 큰 문제로 발전하기 전에 버그를 발견하고 해결 가능
                    지속적 전달의 경우 전체 프로세스가 자동화되어 있어 다른 유형의 테스트를 손쉽게 추가하여 수행 가능

                업데이트를 더 빠르게 제공

                    팀이 좀 더 빠르고, 빈번하게 고객에게 업데이트를 제공 가능
                    지속적 전달이 적절하게 구현되면, 언제나 즉시 배포할 수 있고 표준화된 테스트 프로세스를 통과한 빌드 아티팩트 보유하게 됨

* CI 시스템인 Travis CI, Jenkins, Circle CI, Github Actions, AWS Codebuild 의 차이점과 장단점은 무엇일까요?

        Travis CI

            다양한 레퍼런스가 많고 오픈소스 등에서 많이 사용하는 보편적 CI 도구라고 함
            다양한 언어를 지원하고 Github와 연동이 편리하다고 함
            Travis 자체에서 호스팅을 해주어 관리 측면에서 편리하다고 함(https://travis-ci.com/)
            GitHub는 MS가 인수했고, Travis CI는 GitHub에서 인수했다고 함(GitHub와의 연동이 쉬움)
            직접 서버 운영 필요 없이, Travis CI에서 알아서 VM으로 호스팅해준다고 함
            모든 job이 독립적이라고 함
            오픈소스용 무료 travis.org와 private repository를 위한 유료 travis.com을 별도 운영한다고 함
            규모가 크지 않는 프로젝트거나, 외부 클라우드 서비스 이용 상황 등이면 Jenkins보다는 Travis CI를 사용하는 것이 좋을 수 있다고 함
            커밋과 푸시를 한 브랜치 뿐만 아니라 머지한 브랜치 등에서도 빌드가 작동한다고 함

            Jenkins에 비해 자유도가 낮고, 기능이 아직 부족하다고 함(Jenkins가 플러그인이 많다고 함)
            월 비용이 싼 편이 아니라고 함(https://travis-ci.com/plans)
            로컬에서 CI 환경과 동일한 빌드 환경을 제공하지 않는다고 함
            .travis.yml 파일을 수정하고 테스트하려면 git push를 반복해야 한다고 함
            테스트를 작동시키는 리눅스 환경과 실제 서버가 작동하는 도커 리눅스 환경이 같지 않다고 함
            추가 비용을 통해 더 좋은 빌드 머신을 선택할 수 없다고 함(Travis CI Enterprise에서는 가능)

        Jenkins

            리눅스를 잘한다면 다양한 커스터마이징이 가능하다고 함
            오픈소스(Java 기반)지만 서버는 유료
            지원하는 기능이 풍부하고, 다양하다고 함(알림의 종류, 다양한 IDE 종류, 커스터마이징 등이 다양)
            많은 회사에서 주로 사용하는 도구라고 함
            호스팅을 직접 해야 해서 관련된 모든 부분을 관리 가능
            Jenkins + AWS Code Deploy로 구성하면 많은 라이브러리를 사용할 수 있고 빌드용 서버 비용을 제외하면 무료로 사용 가능하다고 함

            빌드, 배포, 테스트를 각 step별로 하기 위해 groovy 코드를 작성해야 한다고 함
            Travis CI와는 달리 설치형이라 Jenkins 자체를 관리하는 것도 하나의 일이 될 수 있다고 함
            AWS에 독립적인 전용 EC2가 있어야 한다고 함(t2.medium 이상을 권장한다고 함. Build server)
            호스팅을 직접해야 해서 서버 운영 및 관리 비용이 발생(방화벽 작업 등)
            규모가 작은 프로젝트의 경우 설정하는데 리소스 낭비가 발생할 수 있다고 함
            플러그인이 너무 많다고 볼 수도 있다고 함

        Circle CI

            Docker 기반으로 환경을 구성하여 Docker와 매우 흡사하다고 함. circle.yml 작성해서 사용
            Jenkins에 비해 쉽다고 함
            클라우드 환경, 빌드 배포 및 테스트를 step별로 나눠서 가능하다고 함
            AWS와의 연동 가능
            서비스형이라 별도 호스팅이 필요 없다고 함
            Github 저장소 연결이 쉽고 세팅 완료 시 자동 빌드 수행한다고 함
            무료 계정에서도 비공개 저장소 지원한다고 함. 무료 계정의 경우 한번에 하나의 빌드 작업 가능하다고 함
            Github 또는 Bitbucket과 같은 코드 버전 제어 시스템과 통합되어 개발자가 코드를 저장소에 푸시 할 때마다 다양한 단계에서 사전 스크립팅된 테스트 케이스에 대해 테스트하는 파이프 라인을 생성한다고 함
                격리된 컨테이너 또는 가상 머신에서 새로 커밋된 코드를 자동으로 실행한다고 함 -> 에러 발생 시 알림 구성 가능하다고 함

            Private Repository는 유료
            빌드가 많이 필요한 서비스의 경우 Jenkins 같은 서비스의 관리 비용과 가격 비교해보는 것도 좋을 것 같음

        Github Actions

            Github에서 공식적으로 제공하는 CI/CD 툴(개발 워크 플로우 자동화 툴)
                Workflow 자동화된 전체 프로세스를 나타낸 순서도. Github에 YAML 파일로 정의한 자동화 동작을 전달하면 Github Actions는 해당 파일을 기반으로 그대로 실행
                Job 그룹의 역할로 단일 가상 환경 제공한다고 함
                Step Job 안에서 순차적으로 실행되는 프로세스 단위로, 파일 시스템을 통해 서로 정보를 공유, 교환할 수 있음. step에서 명령을 내리거나, action 실행 가능
                Event workflow 실행 기준으로, cron과 같이 시간에 따라 작업을 실행하게 할 수도, git push/pull request 등의 Github Repository 이벤트를 기준으로 실행하게 할 수 있음
            MS의 Github 인수로 공식 기능으로 지원하게 되어 개발 환경이 분산되지 않고 일원화된 개발 환경을 통해 많은 모든 과정을 통합적 관리 가능
            Public Repository는 무료
            npm에 패키지 배포, DockerHub에 이미지 배포, AWS에 서비스 배포, GCP에 서비스 배포하는 작업 등을 GitHub에서 바로 할 수 있다고 함(Git pull request, push를 통해)
            브랜치 별 어떤 Action을 실행할 지 설정할 수 있어 각 개발 팀에 최적화 된 workflow를 만들어 낼 수 있다고 함
            Github actions marketplace에서 커스텀 action 사용 가능하다고 함

            Private Repository에 대해서는 runner(워크플로우 구동 환경)에 따라 분당/시간당 금액을 청구한다고 함(https://github.com/features/actions)
            사용시간에 따른 비용 청구로 빌드가 많이 필요한 서비스의 경우 Jenkins 같은 서비스의 관리 비용과 가격 비교해보는 것도 좋을 것 같음

        AWS Codebuild

            AWS 내에서 소스 코드 컴파일 단계부터 테스트 실행 후 소프트웨어 패키지 개발하여 배포하는 단계까지 마칠 수 있는 완전관리형 지속적 통합 서비스라고 함
            Private Repository도 무료로 가능(빌드 실행한 시간만큼만 지불. 월 100분까지 무료 제공이라고 함)
                메모리 3GB, 2개의 vCPU를 지원하는 build.general1.small 인스턴스 기준 빌드 분당 0.005달러만 지불하면 된다고 함
            플랫폼(Node.js, Java 등)별로 build를 통해 output을 만들 수 있다고 함
            별도의 VPC를 만들고 소스를 빌드해서 artifact라는 output을 만드는 형태라고 함
                라이브러리나 별도 세팅들에 대해 사전 정의가 필요하다고 함
            자체 빌드 서버를 프로비저닝, 관리 및 확장할 필요 없음(빌드 볼륨에 따라 자동 확장 및 축소)
            지속적으로 확장되며 여러 빌드를 동시에 처리하여 빌드가 대기열에서 대기하지 않고 바로 처리 된다고 함
            사전 패키징된 빌드 환경을 사용하면 신속하게 시작할 수 있고 자체 빌드 도구를 사용하는 사용자 지정 빌드 환경을 만들 수 있다고 함
            기존 CI/CD 워크플로에 통합하는 것도 가능하다고 함(기존 Jenkins 서버 설정에서 CodeBuild를 작업자 노드로 사용하여 빌드 분산 가능)
            AWS Key Management Service(KMS)로 관리되는 키를 사용해 빌드 아티팩트가 암호화된다고 함(보안)
            AWS Identity and Access Management(IAM)와 통합되므로 빌드 프로젝트에 사용자별 권한 할당 가능하다고 함
            Buildspec.yml으로 빌드 관리

            AWS IAM에 대한 이해 등이 필요함
            사용시간에 따른 비용 청구로 빌드가 많이 필요한 서비스의 경우 Jenkins 같은 서비스의 관리 비용과 가격 비교해보는 것도 좋을 것 같음



## Quest
* AWS Codebuild를 이용하여, 특정 브랜치에 푸시를 하면 테스트를 한 뒤 모노리포에 있는 모든 패키지가 한 번에 배포되는 시스템을 만들어 보세요.

        ```buildspec.yml on root for CodeBuild(수정 필요함)

            version: 0.2

            phases: 
                install:
                    runtime-versions:
                        nodejs: 
                    commands:
                        - echo Entering install phase...
                pre_build:
                    commands: 
                        - echo Entering pre_build phase... 
                        - npx lerna run lint
                build: 
                    commands:
                        - echo Entering build phase...
                        - ./build.sh
                        - npx lerna run test
                        - ./deploy.sh

        ```

        ```deploy.sh

            #!/bin/bash
        
        ```

* 이 시스템의 CI/CD를 더 효율적으로 할 수 있는 아이디어에는 어떤 것들이 있을까요? 다섯 가지 이상의 아이디어를 제시해 보세요.(https://www.jetbrains.com/ko-kr/teamcity/ci-cd-guide/ci-cd-best-practices/)

        조기에 자주 커밋

            지속적 통합은 작은 업데이트를 더 자주 공유하여 여러 기여자의 변경 사항을 통합하는 프로세스를 보다 간편하게 하는 것
            각각의 커밋은 일련의 자동화된 테스트를 트리거하여 변경 사항에 대한 즉각적 피드백 제공
            주기적 커밋을 통해 팀원들이 동일 기반에서 작업할 수 있어 협업 촉진되고 복잡한 대규모 변경 사항을 통합할 때 병합 충돌의 가능성 감소
            지속적 통합의 이점을 활용하려면 모두가 메인(마스터) 브랜치로 푸시하여 다른 팀원들에게 변경 사용 공유하고 작업 사본을 업데이트하여 다른 모든 사람의 변경 사항 수신(일반적으로 하루에 한 번 이상 메인(마스터) 브랜치 커밋을 목표로 하는 것이 좋음)
                작업을 더 작은 별개의 부분으로 쪼개어 팀으로 일하면 개별 팀원이 이러한 작업 채택에 도움이 될 수 있음
            
        빌드를 그린으로 유지

            문제 발생 즉시 해결하면 훨씬 더 효율적이고 프로덕션에서 문제 발생 시에 수정 사항 신속 적용 가능
            빌드 실패 시 다시 작동하게 수정하는 것이 팀의 우선순위여야 함
            팀원들이 변경 사항을 공유하기 앞서 먼저 빌드를 수행하고 로컬로 초기 테스트 세트를 실행하는 것이 좋음(모두가 CI/CD 시스템과 동일한 스크립트 사용하여 중복 작업 방지)

        단 한 번만 빌드

            여러 환경에 맞춰 소프트웨어를 다시 빌드할 경우 비일관성 오류를 초래할 위험이 있고 이전의 모든 테스트를 통과했다고 확신하기 어려움
            단계별 새 빌드 대신 동일 빌드 아티팩트를 사용해 CI/CD 파이프라인의 각 단계를 진행하고 최종적으로 라이브 릴리스를 완료해야 함
            이를 위해 환경 제약이 없는 빌드가 필요
            모든 변수와 인증 매개변수, 구성 파일 또는 스크립트가 빌드 자체에 통합되는 대신 배포 스크립트로 호출되어야 함
                각 환경에 테스트용으로 동일 빌드 배포할 수 있으며, 단계별로 해당 빌드 아티팩트에 대한 팀의 신뢰도 증가
            빌드 스크립트, 구성 파일 및 배포 스크립트를 포함한 모든 것을 애플리케이션 코드와 동일 소스 관리 시스템에 유지하는 편이 좋지만, 빌드 아티팩트 자체에도 같은 원칙이 적용되지는 않음
            입력의 결과물인 빌드는 소스 관리 시스템에 포함되지 않음
                Nexus 등의 중앙 아티팩트 저장소에서 빌드 버전을 관리하고 저장해야 함. 이러한 저장소에서 빌드를 풀다운하여 각각의 환경에 배포 가능

        테스트 간소화

            CI/CD의 목표는 신속한 피드백을 제공하여 사용자에게 가치 있는 소프트웨어를 기존 방식보다 더욱 빠르게 전달하는 것이므로 테스트 커버리지와 성능 간의 균형 필요
            최대한 빠른 피드백을 위해 가장 신속히 완료되는 테스트 실행하고 빌드에 대해 어느 정도 확신이 가는 경우에만 더 오랜 시간이 소요되는 테스트(GUI 테스트, 성능/부하 테스트, 보안 테스트, 수동 탐색, 수용 테스트)에 투자

        환경 정리

            테스트 프로세스의 적절한 활용을 위해 각 배포 사이의 사전 프로덕션 환경 환경을 정리하는 것이 좋음
            환경이 장기간 실행 중이면, 각 환경에 적용된 모든 구성 변경 사항과 업데이트를 추적하기가 점차 어려워짐
            시간이 흐르며 초기 설정 및 다른 환경과의 차이 발생하기 마련이므로, 특정 환경에서 통과하거나 실패한 테스트가 다른 환경에서 동일 결과 반환하지 않을 수 있음
            정적 환경 유지하는 데 관리 비용이 수반되어 테스트 속도 저해 및 릴리스 프로세스 지연 문제 발생 가능
            컨테이너를 사용하여 환경 호스팅하고 테스트 실행할 경우, 해당 단계를 스크립트로 작성하는 코드로서 인프라 접근 방식을 통해 각각의 새로운 배포를 위한 환경을 간편하게 생성하고 해체 가능
                매번 새로운 컨테이너 인스턴스화 하면 일관성 보장되고 환경을 보다 쉽게 확장할 수 있어 필요한 경우 여러 빌드의 동시 테스트 실행 가능

        신뢰할 수 있는 프로덕션 배포 방식

            안정성, 속도, 보안을 모두 갖춘 CI/CD 파이프라인을 구축하는 데 투자했다면 이는 빌드의 품질에 대한 확신 제공
            자동화된 테스트 단계를 생략하는 경우 방지할 수 있는 이슈를 초래할 위험이 있고 테스트 환경에 배포할 빌드를 쉽게 이용할 수 없어 이슈의 재현 및 디버깅이 훨씬 어려움

        파이프라인 모니터링 및 평가

            CI/CD 도구를 통해 수집한 측정 기준을 분석하여 잠재적 문제와 개선 영역 파악 가능
            주, 일 또는 시간 단위로 트리거 되는 빌드 수를 비교하여 파이프라인 인프라가 사용되는 방식, 확장 또는 축소 필요성, 최대 부하 발생 가능성이 높은 시점 등에 대한 유용한 인사이트 도출 가능
            시간 경과에 따른 배포 속도를 추적하고 더 오랜 시간이 소요되는 경향을 모니터링하면 성능 최적화에 투자할 시점 알 수 있음
            자동화된 테스트로 얻은 통계 자료는 병렬화를 활용하면 좋은 영역을 결정하는 데 도움이 됨
            테스트 결과 검토를 통해 자주 간과하는 부분을 발견하여 테스트 커버리지를 간소화 할 수 있는 영역 파악 가능

        팀으로 협업

            개발자, 테스터 및 운영 팀 간의 통상적 사일로를 제거하고 여러 분야의 협업을 촉진
            소프트웨어 제공과 관련한 공동의 책임감을 조성하여 모든 팀원이 빌드 수정에 참여하거나, 환경 컨테이너화에 시간을 할애하거나 예상만큼 자주 수행되지 않는 수동 작업을 자동화하는 등 팀에 기여하도록 장려 가능